import {type Gen} from '@feltcoop/gro';
import {toRootPath} from '@feltcoop/gro/dist/paths.js';
import {resolve, basename} from 'path';

import {eventInfos} from '$lib/app/events';
import {
	jsonSchemaToTypescript,
	toTypeName,
	type JsonSchemaToTypeScriptOptions,
} from '$lib/util/jsonSchemaToTypescript';
import {schemas} from '$lib/app/schemas';
import {ID_VOCAB_PREFIX} from '$lib/vocab/util';
import {ajv} from '$lib/util/ajv';

/*

TODO so...

should we register external schemas?
or should we infer `https://felt.dev` to be automatically loaded?

need good error messages for `read` below

should the .json suffix be removed?

should there be a schemas dir instead of vocab?

should `gro gen` write schemas to `src/static/schemas`?

*/

ajv();

const toParamsName = (name: string): string => toTypeName(name + 'Params');
const toResponseName = (name: string): string => toTypeName(name + 'Response');
const toResponseResultName = (name: string): string => toTypeName(name + 'ResponseResult');

// Outputs a file with event types that can be imported from anywhere with no runtime cost.
export const gen: Gen = async ({originId}) => {
	const schemaDir = resolve('src/lib/vocab');
	const schemaMatcher = new RegExp(`^${schemaDir}/\\w+\\.json$`);

	const opts: Partial<JsonSchemaToTypeScriptOptions> = {
		cwd: schemaDir,
		$refOptions: {
			resolve: {
				// http: false, // TODO maybe look at felt.dev ones and import?
				file: {
					// canRead: schemaMatcher,
					canRead: true,
					read: (file) => {
						const schemaTitle = ID_VOCAB_PREFIX + basename(file.url);
						const schema = schemas.find((s) => s.$id === schemaTitle);
						console.log('file', file, schemaTitle, !!schema);
						return JSON.stringify(schema);
					},
				},
			},
		},
	};

	return `
// generated by ${toRootPath(originId)}
  
import type {SvelteComponent} from 'svelte';
import type {Readable} from 'svelte/store';

import type {ClientAccountSession} from '$lib/session/clientSession';
import type {ApiResult} from '$lib/server/api';
import type {Community} from '$lib/vocab/community/community';
import type {Persona} from '$lib/vocab/persona/persona';
import type {Membership} from '$lib/vocab/membership/membership';
import type {Space} from '$lib/vocab/space/space';
import type {Entity} from '$lib/vocab/entity/entity';
import type {EntityData} from '$lib/vocab/entity/entityData';
import type {ViewData} from '$lib/vocab/view/view';
import type {DispatchContext} from '$lib/app/dispatch';

export interface EventParamsByName {
	${eventInfos.reduce(
		(str, eventInfo) =>
			str +
			`
${eventInfo.name}: ${toParamsName(eventInfo.name)};
`.trim(),
		'',
	)}
}
export interface EventResponseByName {
	${eventInfos.reduce(
		(str, eventInfo) =>
			str +
			(eventInfo.type === 'ClientEvent'
				? ''
				: `
${eventInfo.name}: ${toResponseName(eventInfo.name)};
`.trim()),
		'',
	)}
}

${await eventInfos.reduce(
	async (str, eventInfo) =>
		(await str) +
		`
${await jsonSchemaToTypescript(eventInfo.params, toParamsName(eventInfo.name), opts)}${
			'response' in eventInfo
				? await jsonSchemaToTypescript(eventInfo.response, toResponseName(eventInfo.name), opts)
				: ''
		}${
			// TODO hacky, the ApiResult type should be represented in the schema
			// but that requires generic type generation:
			// https://github.com/bcherny/json-schema-to-typescript/issues/59
			'response' in eventInfo
				? `	export type ${toResponseResultName(eventInfo.name)} = ApiResult<${toResponseName(
						eventInfo.name,
				  )}>;`
				: ''
		}
`,
	Promise.resolve(''),
)}

export interface Dispatch {
	${eventInfos.reduce(
		(str, eventInfo) =>
			str +
			`
		(
			eventName: '${eventInfo.name}',
			params: ${toParamsName(eventInfo.name)},
		): ${eventInfo.returns};
`.trim(),
		'',
	)}
}

export interface UiHandlers {
  ${eventInfos.reduce(
		(str, eventInfo) =>
			str +
			`
      ${eventInfo.name}: (
        ctx: DispatchContext<${toParamsName(eventInfo.name)}, ${
				eventInfo.type === 'ClientEvent' ? 'void' : toResponseResultName(eventInfo.name)
			}>,
      ) => ${eventInfo.returns};
`.trim(),
		'',
	)}
}

// generated by ${toRootPath(originId)}
`.trim();
};
